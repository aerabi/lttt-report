\chapter*{Abstract}
Event-driven programming as a paradigm is gaining more and more popularity with introducing new technologies such as Rx and the single-threaded asynchronous Node.js. Although many mainstream languages have no support for linear or affine types, the nature of this new event-driven approach is somewhat linear: The program's logic is wrapped into a linear pipeline of callbacks. Furthermore, the monadic style of events and callbacks has a linear nature. Types like promises and observables model variables that are not immediately available, but will become available eventually. These types are a natural resemblance of the linear-time temporal logic's \textit{future} modality.

This dissertation proposes a mixture of linear/non-linear logic and linear-time temporal logic to model the type system in event-driven programming. The practicality of this framework is examined via a number of examples. A Coq implementation of the typing rules is there to verify the soundness of the system. And a TypeScript implementation tries to set infrastructure to discuss the suitability of the framework for practical use.

\chapter*{Zusammenfassung}
Die ereignisgesteuerte Programmierung als Paradigma gewinnt mit der Einführung neuer Technologien wie Rx und der asynchronen Single-Thread-Node.js immer mehr an Beliebtheit. Obwohl viele Mainstream-Sprachen keine Unterstützung für lineare oder affine Typen bieten, ist die Natur dieses neuen ereignisgesteuerten Ansatzes etwas linear: Die Logik des Programms ist in eine lineare Pipeline von Rückrufen eingebunden. Darüber hinaus ist der monadische Stil von Ereignissen und Rückrufen linear. Typen wie Versprechen und beobachtbare Modellvariablen, die nicht sofort verfügbar sind, aber irgendwann verfügbar sein werden. Diese Typen sind eine natürliche Ähnlichkeit mit der \textit{irgendwann}-Modalität der zeitlichen Logik der linearen Zeit.

Diese Dissertation schlägt eine Mischung aus linearer / nichtlinearer Logik und zeitlich linearer Logik vor, um das Typsystem in der ereignisgesteuerten Programmierung zu modellieren. Die Praktikabilität dieses Rahmens wird anhand einer Reihe von Beispielen untersucht. Eine Coq-Implementierung der Typisierungsregeln dient dazu, die Solidität des Systems zu überprüfen. Eine TypeScript-Implementierung versucht, eine Infrastruktur einzurichten, um die Eignung des Frameworks für den praktischen Gebrauch zu erörtern.