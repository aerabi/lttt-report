\section{Embedding Linear Types in TypeScript}

The \texttt{Observable} type of RxJS is already a very good model to study linear events, but it is too complicated. We need a more limited and controlled version of an \texttt{Observable}. In particular, we need our new monadic type to satisfy the following criteria:
\begin{itemize}
    \item Wrap exactly one event (just like \texttt{Promise} or \texttt{Single} of RxJava).
    \item Expose one binding interface (similar to \texttt{Promise}'s \texttt{next}), rather than dozens like in \texttt{Observable}.
    \item Be linear (unlike \texttt{Promise} that can be used indefinitely).
\end{itemize}

% Embedding linear type systems in non-linear host languages was studied by \cite{JenniferPaykin2018}. In this chapter we describe the implementation of the type system presented in Chapter \ref{chapter:the-type-system} in TypeScript as the host language.

The key ingredients to create such a type system are the following:
\begin{itemize}
    \item A class \texttt{Lin<}$\T$\texttt{>} that implements $\floor{\T}$, to create an embedded linear type system into TypeScript, that lacks it.
    \item A class that implements $\diamond\A$, based on a \texttt{Lin}.
\end{itemize}

The explanations that follow are based on the TypeScript implementation of \texttt{Lin}, \texttt{LPromise}, and \texttt{Single}\footnote{\url{https://github.com/aerabi/lttt-typescript}}.

\section{Linear Type of \texttt{Lin}}
Type \texttt{Lin} is implemented as a TypeScript class.
One can create a linear variable from a non-linear value by calling on the constructor of \texttt{Lin}:

\begin{minted}{typescript}
const lin: Lin<number> = new Lin(12);
\end{minted}

And to read the value later, one needs to call on the class method \texttt{read}:

\begin{minted}{typescript}
console.log(lin.read());
\end{minted}

The \texttt{read} method cannot be called more than once; it will through an error on the second attempt. And code linters such as TSLint and ESLint can guard against the variable not being used.

The types \texttt{LUnit} and \texttt{LZero} are special cases of the type \texttt{Lin}:

\begin{minted}{typescript}
export type LUnit = Lin<undefined>;
export type LZero = Lin<void>;
\end{minted}

\section{Eager Type of \texttt{LPromise}}

As presented in \chapref{chapter:the-type-system}, the modal $\diamond$ exists in the linear fragment of the logic. In our setting, we need to use \texttt{Lin} to convert an unrestricted type into a linear one, and then apply the modality on it.

This section explains the type \texttt{LPromise<}$\T$\texttt{>}, which is an implementation of $\diamond\floor{\T}$ (so the generic unrestricted type is converted into a linear type under the hood):

\begin{minted}{typescript}
let lpromise: LPromise<string>;
\end{minted}

The \texttt{LPromise} type wraps a linear value that is not necessarily available immediately. One can create a single from a value or a \texttt{Promise}:

\begin{minted}{typescript}
const lp1 = LPromise.fromLinearValue(lin);
const lp2 = LPromise.fromValue(12);
const lp3 = LPromise.fromPromise(Promise.resolve(12));
\end{minted}

The values are wrapped into a linear variable under the hood, so all of the 3 introduced variables (\texttt{lp1} and \texttt{lp2} and \texttt{lp3}) are equal.

There is a \texttt{bind} method that will read the value of the eventual linear variable and pass it to the callback function:

\begin{minted}{typescript}
const lpromise = LPromise.fromValue(12);
lpromise.bind(x => expect(x).toEqual(12));
\end{minted}

And, in contrast to \texttt{Observable}s and \texttt{Promise}s, a \texttt{Single} cannot be bound twice:

\begin{minted}{typescript}
lpromise.bind(x => ...);  // first time, OK
lpromise.bind(x => ...);  // second time, error
\end{minted}

\section{Lazy Type of \texttt{Single}}

A \texttt{Single} is very similar to an \texttt{LPromise}, except for its laziness: The callbacks are only computed when the \texttt{exec} method is called.

\begin{minted}{typescript}
const single = Single.fromValue(12);
single.bind(console.log);  // nothing happens...
single.exec(() => {});     // now, it prints to console
\end{minted}

\section{Linear Embedded Language}
One can describe the language of the embedded linear types as follows:
\[
\A ::= \mathtt{LUnit} \mid \mathtt{LZero} \mid \mathtt{[}\A, \A\mathtt{]} \mid \A\mbox{~\texttt{=>}~} \A \mid \mbox{\texttt{Lin<}}\T\mbox{\texttt{>}} \mid \mbox{\texttt{Single<}}\A\mbox{\texttt{>}}.
\]