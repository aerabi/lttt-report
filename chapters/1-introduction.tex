\chapter{Introduction}\label{chap:introduction}

In this work, we implemented the linear-time temporal type theory, LTTT, in Coq. LTTT is first introdcued by \cite{Paykin2016TheEO} to lay a basis to study event-driven programming. Particularly, we implemented typing rules and an operational semantics, and proved some results about them (among them some stronger linear and non-linear preservation results) mechanically in Coq. We implemented a generic store in Coq that is used as the linear and non-linear context for the typing relations. Some 45 lemmas and propositions are proved about the store to make it more practical. And finally, we implemented an embedded version of LTTT in TypeScript to show the theory in action. The TypeScript implementation tries to embed linearity into the non-linear type system of TS and create a controlled version of RxJS's observable.

\section{Motivation}

Event-driven programming is becoming the standard paradigm for programming in almost every domain: backend, frontend, GUI, etc. All of the framework and library vendors are now offering \textit{reactive}, \textit{i.e.} event-driven interfaces for their products. Spring framework came up with WebFlux, Angular is all wrapped in RxJS's observables, and Node.js is async by nature. Reactive drivers are being implemented for databases, to support an end-to-end reactive spectrum.

Unfortunately, event-driven programming can be difficult, as it is a combination of two seemingly contradictory elements: callbacks and states. When callbacks change the state of a program, we say they have \textit{side effects}, a very unpopular term among developers (e.g. see \cite{aerabi_2020}).

To overcome these problems, many different and somewhat ad hoc approaches were taken. Scala, as an example, has at least 3 different built-in abstractions for event types: \texttt{Promise}, \texttt{Future}, and \texttt{Signal} (\cite{deprecating2010}), putting RxScala aside. And of course we have access to Java libraries in Scala, adding Reactor and similar abstractions to the bunch.

In such a time, laying a basis for event-driven programming seems necessary more than ever.

This work aims to study event-driven programming by identifying structures common to it with a natural perspective from temporal logic. Under this correspondence, an event (specially in the Rx or \texttt{Promise} sense) is computation that can eventually return a value, and can be identified with the temporal logic's \textit{eventually}/\textit{future} modality $\diamond\A$.

A correspondence between linear-time temporal logic (LTL) and event-driven programming is presented in terms of Curry--Howard correspondence, and then is tried to be verified with an implementation in the proof-assistant Coq language (\cite{mohammad_ali_a_rabi_2021_4749276}). A novel reformulation of the theory behind LTL and Curry--Howard correspondence is also presented. And finally a TypeScript implementation tries to relate the theory to real-life production code written in JavaScript/TypeScript.

% \subsection{TypeScript Embedding}

% Linear and affine types are not supported by many mainstream programming languages. \cite{JenniferPaykin2018} worked on embedding linear types in non-linear host languages. She particularly implemented an embedding for Coq and Haskell.

% To study event-driven programming in action, we chose JavaScript for multiple reasons. To name one, the server-side JS is async by nature, and hence most of the logic written in Node.JS are wrapped into callbacks or async types such as \texttt{Promise} and \texttt{Observable}.

% TypeScript is currently the typed version of JavaScript and hence was used for our study. But, there are fundamental differences between TypeScript and Haskell or Coq. Types in TypeScript are parts of the metalanguage and are not shipped to the executable code. Hence, one has very limited access to types in the runtime and particularly cannot store them in a key-value store.

% So, to embed linearity into TypeScript/JavaScript, one should employ logic that has similar behavior.

\input{chapters/1-1-thesis-statement}
\input{chapters/1-2-conventions}